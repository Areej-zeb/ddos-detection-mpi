#include "blocking.h"
#include <string.h>
#include <stdio.h>

static BlockedIP blocklist[MAX_BLOCKED_IPS];
static int blocklist_count = 0;

// Initialize blocklist
void init_blocklist()
{
    blocklist_count = 0;
    memset(blocklist, 0, sizeof(blocklist));
}

// Add IP to blocklist (RTBH simulation)
int add_to_blocklist(const char *ip, double timestamp)
{
    // Check if already blocked
    for (int i = 0; i < blocklist_count; i++)
    {
        if (strcmp(blocklist[i].ip, ip) == 0)
        {
            return 0; // Already blocked
        }
    }

    // Add new entry
    if (blocklist_count < MAX_BLOCKED_IPS)
    {
        strncpy(blocklist[blocklist_count].ip, ip, MAX_IP_LEN - 1);
        blocklist[blocklist_count].ip[MAX_IP_LEN - 1] = '\0';
        blocklist[blocklist_count].blocked_time = timestamp;
        blocklist_count++;
        return 1; // Successfully added
    }

    return -1; // Blocklist full
}

// Check if IP is blocked
int is_blocked(const char *ip)
{
    for (int i = 0; i < blocklist_count; i++)
    {
        if (strcmp(blocklist[i].ip, ip) == 0)
        {
            return 1;
        }
    }
    return 0;
}

// Get current blocklist
int get_blocklist(BlockedIP *list, int max_size)
{
    int count = (blocklist_count < max_size) ? blocklist_count : max_size;
    memcpy(list, blocklist, count * sizeof(BlockedIP));
    return count;
}

// Clear blocklist
void clear_blocklist()
{
    blocklist_count = 0;
}

// Generate FlowSpec BGP rules for blocked IPs
void generate_flowspec_rules(const char *filename, BlockedIP *blocklist, int count)
{
    FILE *fp = fopen(filename, "w");
    if (!fp)
    {
        fprintf(stderr, "[Blocking] Error: Cannot create FlowSpec rules file %s\n", filename);
        return;
    }

    fprintf(fp, "# BGP FlowSpec Rules - Generated by DDoS Detection System\n");
    fprintf(fp, "# RFC 5575 - Dissemination of Flow Specification Rules\n");
    fprintf(fp, "# Format: match <conditions> then <actions>\n\n");

    for (int i = 0; i < count; i++)
    {
        fprintf(fp, "flow route {\n");
        fprintf(fp, "    match {\n");
        fprintf(fp, "        source %s/32;\n", blocklist[i].ip);
        fprintf(fp, "        protocol tcp;\n");
        fprintf(fp, "    }\n");
        fprintf(fp, "    then {\n");
        fprintf(fp, "        discard;\n");
        fprintf(fp, "        community 65535:666;  # Blackhole community\n");
        fprintf(fp, "    }\n");
        fprintf(fp, "}\n\n");
    }

    fprintf(fp, "# Total rules: %d\n", count);
    fclose(fp);
    printf("[Blocking] FlowSpec rules saved to %s\n", filename);
}

// Generate ACL (Access Control List) rules for blocked IPs
void generate_acl_rules(const char *filename, BlockedIP *blocklist, int count)
{
    FILE *fp = fopen(filename, "w");
    if (!fp)
    {
        fprintf(stderr, "[Blocking] Error: Cannot create ACL rules file %s\n", filename);
        return;
    }

    fprintf(fp, "# ACL Rules - Generated by DDoS Detection System\n");
    fprintf(fp, "# Cisco IOS / ASA Format\n\n");
    fprintf(fp, "ip access-list extended DDOS_BLOCK\n");

    for (int i = 0; i < count; i++)
    {
        fprintf(fp, " deny ip host %s any log\n", blocklist[i].ip);
    }

    fprintf(fp, " permit ip any any\n\n");
    fprintf(fp, "# Apply to interface:\n");
    fprintf(fp, "# interface GigabitEthernet0/0\n");
    fprintf(fp, "#  ip access-group DDOS_BLOCK in\n\n");
    fprintf(fp, "# Total blocked IPs: %d\n", count);
    fclose(fp);
    printf("[Blocking] ACL rules saved to %s\n", filename);
}
